---
title: "argila_dnos"
author: "LC"
date: "4 de dezembro de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.



#Modelagem geoestatística do conteúdo de argila da bacia do DNOS



Primeiramente serão instalados os pacotes necessários para o carregamento das funções que serão utilizadas no desenvolvimento de todo o trabalho. Embora sejam utilizadas em diferentes partes do trabalho, para fins práticos recomenda-se que estes sejam instalados em sua totalidade para o bom andamento das análises. Para o carregamento dos dados do FEBR, que deve ser instalado a partir do github, utiliza-se o comando devtools::install_github
```{r}
install.packages("mapview")
install.packages("devtools")
devtools::install_github("febr-team/febr-package", dependencies=TRUE)
install.packages("magrittr")
install.packages("dplyr")
install.packages("glue")
install.packages("lattice")
install.packages("latticeExtra")
install.packages("georob")
install.packages("sp")
install.packages("rgdal")
```

Após os pacotes serem instalados, devem ser carregados (a partir do comando library)
```{r}
library(mapview)
library(devtools)
library(febr)
library(magrittr)
library(dplyr)
library(glue)
library(lattice)
library(latticeExtra)
library(georob)
library(sp)
library(rgdal)
```
Devemos também definir o sistema de referência de coordenadas geográficas (Fonte: http://spatialreference.org/ref/epsg/) utilizadas, além de uma rampa de cores que serão utilizadas na geração dos mapas.
```{r}

wgs84utm22s <- sp::CRS('+proj=utm +zone=22 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs')
sirgas2000 <- sp::CRS('+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs')

col_soil_var <- topo.colors(100)
```

Com os pacotes carregados, serão baixados os dados do FEBR para a área estudada. Primeiramente serão descarregados os arquivos do mapa pedológico para a área estudada.
```{r}
data_folder <- '../data/'
ext <- c('dbf', 'prj', 'shp', 'shx')
files <- (glue('pedologia25.{ext}'))
download <- !all(files %in% list.files(data_folder))
if (download) {
  url <- 'https://github.com/samuel-rosa/UFSM-SOL-843/tree/master/data/'
  url <- glue('{url}{files}')
  destfile <- glue('{data_folder}{files}')
  for (i in 1:length(files)) {
    download.file(url = url[i], destfile = destfile[i])
  }
}

```

```{r}
pedologia25 <- 
  glue('../data/pedologia25.shp') %>% 
  raster::shapefile(stringsAsFactors = TRUE) %>% 
  sp::spTransform(wgs84utm22s)


col_soil_um <- terrain.colors(nlevels(pedologia25$um))
str(pedologia25)
pedologia25@data

```

Será descarregado da base de dados do FEBR o conjunto de dados ctb0003, referente ao conjunto de dados do solo da bacia do reservatório do DNOS-CORSAN, Santa Maria, RS.

```{r}
#pontos400_0 = dnos_observations e pontos400_l = dnos_layers
#pontos 400 = dnos

dnos_observations <- febr::observations('ctb0003', which.cols = 'all', progress = FALSE)
dnos_layers <- febr::layers('ctb0003', soil.vars = "argila", which.cols = 'all', missing.data = 'keep', progress = FALSE)

id <- c('dataset_id', 'observacao_id')
dnos <- 
  merge(dnos_observations, dnos_layers, by.x = id, by.y = id) %>% 
  select(observacao_id, coord_x, coord_y, taxon_sibcs_2009, ca_kcl_aas, argila_, areia_)
rm(dnos_layers, dnos_observations)
sp::coordinates(dnos) <- ~ coord_x + coord_y
sp::proj4string(dnos) <- sirgas2000
dnos <- sp::spTransform(dnos, wgs84utm22s)

dnos$um <- sp::over(x = dnos, y = pedologia25) %>% unlist()

dnos_in <- dnos[!is.na(dnos$um), ]
```

Será plotado o mapa com a localização dos pontos amostrais distribuidos sobre o mapa pedológico da área.
```{r plot do mapa pedologico}
sp::spplot(
  pedologia25, col.regions = col_soil_um, alpha.regions = 0.3, colorkey = FALSE) +
  latticeExtra::as.layer(
    lattice::xyplot(coord_y ~ coord_x, data = as.data.frame(dnos_in@coords), col = 'blue', pch = 16))
```

#Parte I - Modelagem clássica 

A partir dos dados carregados, começa a predição pelo modelo clássico, determinando o conteúdo de argila única e exclusivamente como função do mapa pedológico, utilizando média por classe usando modelo linear simples.

```{r}
lm_fit <- lm(argila_ ~ um, dnos_in)
summary(lm_fit)
```

```{r}
dmax <- max(dist(dnos_in@coords))/2 #foi calculada a distancia maxima, para posteriormente ser usada no limite máximo dos residuos do semivariograma

limites <- seq(0, dmax, length.out = 15)
residuals(lm_fit) %>% 
  georob::sample.variogram(
    locations = dnos_in@coords, lag.dist.def = limites,
    xy.angle.def = c(0, 22.5, 67.5, 112.5, 157.5, 180)) %>% 
  plot(type = "b", ylab = 'Semivariância', xlab = 'Distância de separação (km)', cex = 1.0, lwd = 1.0)
```

```{r}
plot(variogram_lm, type = "b", xlab = 'Distância de separação (m)', ylab = 'Semivariância')
lines(vario_fit, col = "red", lty = 'dashed', lwd = 1.5)
```

#testar com o gstat
```{r}
#Predições espaciais

mapa_exp <- gstat::krige(residuo ~ 1, pontos400in, grid, m_exp, debug.level = 1)
sp::gridded(mapa_exp) <- TRUE
sp::spplot(mapa_exp, 1, col.regions = col_soil_var)
mapa_exp$var1.var <- sqrt(mapa_exp$var1.var)
sp::spplot(mapa_exp, 2, col.regions = col_soil_var)
```

#ou predizer diretamente pelo lm_fit, sem o nugget pelo georob, abaixo



```{r}
grid <- sp::spsample(dnos_in, 10000, type = 'regular')

```


```{r}
str(dnos_in)

colnames(grid@coords) <- colnames(dnos_in@coords)
pred_ponto <- predict(
  reml_fit, newdata = grid, type = 'signal', signif = 0.95,
  control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_ponto) <- TRUE
str(pred_ponto)
```

```{r}
at <- pred_ponto@data[, c("pred", "lower", "upper")] %>% range()
at <- seq(at[1], at[2], length.out = 20)
sp::spplot(pred_ponto, zcol = c("lower", "pred", "upper"), at = at, main = "prediction")
```

```{r}
sp::spplot(pred_ponto, zcol = 'se')
```

Validação cruzada do modelo utilizando apenas krigagem ordinária.

```{r}
validacao <- georob::cv(reml_fit, nset = 375)
summary(validacao)
```

```{r}
1 - sum((validacao$pred$data - validacao$pred$pred)^2) / 
  sum((validacao$pred$data - mean(validacao$pred$data))^2)

plot(validacao)

```






#Parte II - Modelagem puramente espacial
Predição do conteúdo de argila no solo na bacia do DNOS usando apenas krigagem ordinária.

```{r}
lm_fit <- lm(argila_ ~ 1, dnos_in)
summary(lm_fit)
```

```{r}
limites <- seq(0, 1800, length.out = 15)
residuals(lm_fit) %>% 
  georob::sample.variogram(
    locations = dnos_in@coords, lag.dist.def = limites,
    xy.angle.def = c(0, 22.5, 67.5, 112.5, 157.5, 180)) %>% 
  plot(type = "b", ylab = 'Semivariância', xlab = 'Distância de separação (km)')
```

```{r}
vario <- 
  residuals(lm_fit) %>% 
  georob::sample.variogram(
    locations = dnos_in@coords, lag.dist.def = limites)
vario_fit <- 
  georob::fit.variogram.model(
  vario, variogram.model = 'RMexp', param = c(variance = 20000, nugget = 1000, scale = 200), 
  weighting.method = "cressie", method = "BFGS")
```

```{r}
reml_fit <- georob::georob(
  argila_ ~ 1, dnos_in, locations = ~ coord_x + coord_y, 
  variogram.model = 'RMexp', 
  param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
            nugget = vario_fit$variogram.object[[1]]$param[['nugget']], 
            scale = vario_fit$variogram.object[[1]]$param[['scale']]),
  tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))
summary(reml_fit)
```

```{r}
plot(vario, type = "b", xlab = 'Distância de separação (m)', ylab = 'Semivariância')
lines(vario_fit, col = "red", lty = 'dashed')
```

```{r}
grid <- sp::spsample(dnos_in, 10000, type = 'regular')

```


```{r}
str(dnos_in)

colnames(grid@coords) <- colnames(dnos_in@coords)
pred_ponto <- predict(
  reml_fit, newdata = grid, type = 'signal', signif = 0.95,
  control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_ponto) <- TRUE
str(pred_ponto)
```

```{r}
at <- pred_ponto@data[, c("pred", "lower", "upper")] %>% range()
at <- seq(at[1], at[2], length.out = 20)
sp::spplot(pred_ponto, zcol = c("lower", "pred", "upper"), at = at, main = "prediction")
```

```{r}
sp::spplot(pred_ponto, zcol = 'se')
```

Validação cruzada do modelo utilizando apenas krigagem ordinária.

```{r}
validacao <- georob::cv(reml_fit, nset = 375)
summary(validacao)
```

```{r}
1 - sum((validacao$pred$data - validacao$pred$pred)^2) / 
  sum((validacao$pred$data - mean(validacao$pred$data))^2)

plot(validacao)
```



parte iv

esta na tabela apresentada na aula 3 - 

(RE)ML Gaussiano
reml_fit <- georob::georob(
  areia_ ~ um + geo, pontos400in, locations = ~ coord_x + coord_y, variogram.model = 'RMexp', 
  param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
            nugget = vario_fit$variogram.object[[1]]$param[['nugget']], 
            scale = vario_fit$variogram.object[[1]]$param[['scale']]),
  tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))
summary(reml_fit)
plot(vario, type = "b", xlab = 'Distância de separação (m)', ylab = 'Semivariância')
lines(vario_fit, col = "red", lty = 'dashed')
lines(reml_fit, col = "blue", lty = 'dashed')
prof_reml_fit_scale <- 
  georob::profilelogLik(object = reml_fit, values = data.frame(scale = seq(50, 350, by = 10)))
```{r loglik-scale, error=TRUE, fig.asp=1, fig.cap='Perfil da função logarítmica da verossimilhança restrita para o parâmetro alcance (scale). A linhas verticais representam a estimativa e intervalo de confiança do parâmetro alcance. A interseção entre a linha horizontal e o perfil indica a região de 95% de confiança para o parâmetro alcance segundo o teste da razão de verossimilhança.'} plot(loglik ~ scale, prof_reml_fit_scale, type = "l") abline(v = summary(reml_fit)$param.aniso[[1]]['scale', ], lty = c("dashed", rep('dotted', 2)), col = 'red') abline(h = reml_fit$loglik - 0.5 * qchisq(0.95, 1), lty = "dotted")


```{r, fig.width=14, fig.height=7, fig.cap='Relação das estimativas da variância parcial (`variance`) e da variância residual (`nugget`) com as estimativas do alcance (`scale`).'}
op <- par(mfrow = c(1, 2))
plot(variance ~ scale, prof_reml_fit_scale, ylim = c(0, max(variance)), type = "l")
plot(nugget ~ scale, prof_reml_fit_scale, ylim = c(0, max(nugget)), type = "l")
par(op)


parte da geração do semivariograma pelo modelo linear, que não foi usada pelo fato do georob nao aceitar o modelo nugget
```{r}
variogram_lm <- 
  residuals(lm_fit) %>% 
  georob::sample.variogram(
    locations = dnos_in@coords, lag.dist.def = limites)
vario_fit <- 
  georob::fit.variogram.model(
  variogram_lm, variogram.model = 'RMnugget', param = c(variance = var(lm_fit$residuals)))

```