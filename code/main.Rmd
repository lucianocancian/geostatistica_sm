---
title: "argila_dnos"
author: "LC"
date: "4 de dezembro de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.



#Modelagem geoestatística do conteúdo de argila da bacia do DNOS



Primeiramente serão instalados os pacotes necessários para o carregamento das funções que serão utilizadas no desenvolvimento de todo o trabalho. Embora sejam utilizadas em diferentes partes do trabalho, para fins práticos recomenda-se que estes sejam instalados em sua totalidade para o bom andamento das análises. Para o carregamento dos dados do FEBR, que deve ser instalado a partir do github, utiliza-se o comando devtools::install_github

```{r}
install.packages("mapview")
install.packages("devtools")
devtools::install_github("febr-team/febr-package", dependencies=TRUE)
install.packages("magrittr")
install.packages("dplyr")
install.packages("glue")
install.packages("lattice")
install.packages("latticeExtra")
install.packages("georob")
install.packages("sp")
install.packages("rgdal")
install.packages("raster", dependencies = TRUE)
install.packages("caret", dependencies = TRUE)
```

Após os pacotes serem instalados, devem ser carregados (a partir do comando library)
```{r}
library(mapview)
library(devtools)
library(febr)
library(magrittr)
library(dplyr)
library(glue)
library(lattice)
library(latticeExtra)
library(georob)
library(sp)
library(rgdal)
require(raster)
library(caret)
```

Devemos também definir o sistema de referência de coordenadas geográficas (Fonte: http://spatialreference.org/ref/epsg/) utilizadas, além de uma rampa de cores que serão utilizadas na geração dos mapas.
```{r}

wgs84utm22s <- sp::CRS('+proj=utm +zone=22 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs')
sirgas2000 <- sp::CRS('+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs')

col_soil_var <- topo.colors(100)
```

Com os pacotes carregados, serão baixados os dados do FEBR para a área estudada. Primeiramente serão descarregados os arquivos do mapa pedológico para a área estudada.
```{r}
data_folder <- '../data/'
ext <- c('dbf', 'prj', 'shp', 'shx')
files <- (glue('pedologia25.{ext}'))
download <- !all(files %in% list.files(data_folder))
if (download) {
  url <- 'https://github.com/samuel-rosa/UFSM-SOL-843/tree/master/data/'
  url <- glue('{url}{files}')
  destfile <- glue('{data_folder}{files}')
  for (i in 1:length(files)) {
    download.file(url = url[i], destfile = destfile[i])
  }
}

```

```{r}
pedologia25 <- 
  glue('../data/pedologia25.shp') %>% 
  raster::shapefile(stringsAsFactors = TRUE, encoding = 'UTF-8') %>% 
  sp::spTransform(wgs84utm22s)

str(pedologia25)
pedologia25@data

col_soil_um <- terrain.colors(nlevels(pedologia25$um))
```

Será descarregado da base de dados do FEBR o conjunto de dados ctb0003, referente ao conjunto de dados do solo da bacia do reservatório do DNOS-CORSAN, Santa Maria, RS.

```{r}
dnos_observations <- febr::observations('ctb0003', which.cols = 'all', progress = FALSE)
dnos_layers <- febr::layers('ctb0003', soil.vars = "argila", which.cols = 'all', missing.data = 'keep', progress = FALSE)

id <- c('dataset_id', 'observacao_id')
dnos <- 
  merge(dnos_observations, dnos_layers, by.x = id, by.y = id) %>% 
  select(observacao_id, coord_x, coord_y, taxon_sibcs_2009, argila_)
rm(dnos_layers, dnos_observations)
sp::coordinates(dnos) <- ~ coord_x + coord_y
sp::proj4string(dnos) <- sirgas2000
dnos <- sp::spTransform(dnos, wgs84utm22s)

dnos$um <- sp::over(x = dnos, y = pedologia25) %>% unlist()

dnos_in <- dnos[!is.na(dnos$um), ]
```

Será plotado o mapa com a localização dos pontos amostrais distribuidos sobre o mapa pedológico da área.
```{r plot do mapa pedologico}
sp::spplot(
  pedologia25, col.regions = col_soil_um, alpha.regions = 0.3, colorkey = FALSE) +
  latticeExtra::as.layer(
    lattice::xyplot(coord_y ~ coord_x, data = as.data.frame(dnos_in@coords), col = 'blue', pch = 16))
```

#Parte I - Modelagem clássica 

A partir dos dados carregados, começa a predição pelo modelo clássico, determinando o conteúdo de argila única e exclusivamente como função do mapa pedológico, utilizando média por classe usando modelo linear simples.

```{r}
lm_fit <- lm(argila_ ~ um, dnos_in)
summary(lm_fit)
```

```{r}
dmax <- max(dist(dnos_in@coords))/2 #foi calculada a distancia maxima, para posteriormente ser usada no limite máximo dos residuos do semivariograma

limites <- seq(0, dmax, length.out = 15)
residuals(lm_fit) %>% 
  georob::sample.variogram(
    locations = dnos_in@coords, lag.dist.def = limites,
    xy.angle.def = c(0, 22.5, 67.5, 112.5, 157.5, 180)) %>% 
  plot(type = "b", ylab = 'Semivariância', xlab = 'Distância de separação (km)', cex = 1.0, lwd = 1.0)
```

#predizer diretamente pelo lm_fit, sem o nugget pelo georob, abaixo



```{r}
grid <- sp::spsample(dnos_in, 10000, type = 'regular')

```


```{r}
colnames(grid@coords) <- colnames(dnos_in@coords)
pred_linear <- predict(
  lm_fit, newdata = grid, type = 'signal', signif = 0.95,
  control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_linear) <- TRUE
str(pred_linear)
```

```{r}
at <- pred_linear@data[, c("pred", "lower", "upper")] %>% range()
at <- seq(at[1], at[2], length.out = 20)
sp::spplot(pred_linear, zcol = c("lower", "pred", "upper"), at = at, main = "prediction")
```

```{r}
sp::spplot(pred_linear, zcol = 'se')
```

Validação cruzada do modelo utilizando apenas krigagem ordinária.

```{r}
validacao <- georob::cv(lm_fit, nset = 375)
summary(validacao)
```

```{r}
1 - sum((validacao$pred$data - validacao$pred$pred)^2) / 
  sum((validacao$pred$data - mean(validacao$pred$data))^2)

plot(validacao)

```





#Parte II - Modelagem puramente espacial
Predição do conteúdo de argila no solo na bacia do DNOS usando apenas krigagem ordinária.

```{r}
ko <- lm(argila_ ~ 1, dnos_in)
summary(ko)
```

```{r}
limites <- seq(0, 1500, length.out = 15)
residuals(ko) %>% 
  georob::sample.variogram(
    locations = dnos_in@coords, lag.dist.def = limites,
    xy.angle.def = c(0, 22.5, 67.5, 112.5, 157.5, 180)) %>% 
  plot(type = "b", ylab = 'Semivariância', xlab = 'Distância de separação (km)')
```

```{r}
vario <- 
  residuals(ko) %>% 
  georob::sample.variogram(
    locations = dnos_in@coords, lag.dist.def = limites)
vario_fit <- 
  georob::fit.variogram.model(
  vario, variogram.model = 'RMexp', param = c(variance = 20000, nugget = 1000, scale = 200), 
  weighting.method = "cressie", method = "BFGS")
```

```{r}
reml_fit <- georob::georob(
  argila_ ~ 1, dnos_in, locations = ~ coord_x + coord_y, 
  variogram.model = 'RMexp', 
  param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
            nugget = vario_fit$variogram.object[[1]]$param[['nugget']], 
            scale = vario_fit$variogram.object[[1]]$param[['scale']]),
  tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))
summary(reml_fit)
```

```{r}
plot(vario, type = "b", xlab = 'Distância de separação (m)', ylab = 'Semivariância')
lines(vario_fit, col = "red", lty = 'dashed')
```

```{r}
grid <- sp::spsample(dnos_in, 10000, type = 'regular')
```


```{r}
colnames(grid@coords) <- colnames(dnos_in@coords)
pred_ponto <- predict(
  reml_fit, newdata = grid, type = 'signal', signif = 0.95,
  control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_ponto) <- TRUE
str(pred_ponto)
```

```{r}
at <- pred_ponto@data[, c("pred", "lower", "upper")] %>% range()
at <- seq(at[1], at[2], length.out = 20)
sp::spplot(pred_ponto, zcol = c("lower", "pred", "upper"), at = at, main = "prediction")
```

```{r}
krig_ko <- sp::spplot(pred_ponto, zcol = 'se')
plot(krig_ko)
```

Validação cruzada do modelo utilizando apenas krigagem ordinária.

```{r}
validacao <- georob::cv(reml_fit, nset = 375)
summary(validacao)
```

```{r}
1 - sum((validacao$pred$data - validacao$pred$pred)^2) / 
  sum((validacao$pred$data - mean(validacao$pred$data))^2)

plot(validacao)
```


```{r}
# Incerteza
cond_sim_ko <- gstat::krige(argila_ ~ 1, dnos_in, grid, model = m_exp, nmax = 15, nsim = 8)
gridded(cond_sim_ko) <- TRUE
spplot(cond_sim_ko)
```

```{r}
beta_ko <- lm(argila_ ~ 1, dnos_in@data) %>% coef()
g_ko <- gstat::gstat(formula = z ~ 1, dummy = TRUE, model = m_exp, nmax = 15, beta = beta)
uncond_sim_ko <- predict(g_ko, grid, nsim = 8)
gridded(uncond_sim_ko) <- TRUE
spplot(uncond_sim_ko)
```

```{r}
uncond_sim_prop_ko <- 
  calc(stack(uncond_sim_ko), function (x) x > 50) %>% 
  calc(sum) %>% 
  calc(function (x) x / 8)
plot(uncond_sim_prop_ko, asp = 1)
```


#Parte III - Modelagem espacial, fazendo uso de krigagem universal utilizando o mapa pedológico como covariável.

```{r}
ku <- lm(argila_ ~ um, dnos_in)
summary(ku)
```

```{r}
limites <- seq(0, 1500, length.out = 15)
residuals(ku) %>% 
  georob::sample.variogram(
    locations = dnos_in@coords, lag.dist.def = limites,
    xy.angle.def = c(0, 22.5, 67.5, 112.5, 157.5, 180)) %>% 
  plot(type = "b", ylab = 'Semivariância', xlab = 'Distância de separação (km)')
```

```{r}
vario <- 
  residuals(ku) %>% 
  georob::sample.variogram(
    locations = dnos_in@coords, lag.dist.def = limites)
vario_fit <- 
  georob::fit.variogram.model(
  vario, variogram.model = 'RMexp', param = c(variance = 20000, nugget = 900, scale = 200), 
  weighting.method = "cressie", method = "BFGS")
summary(vario_fit)
```

```{r}
reml_ku <- georob::georob(
  argila_ ~ um, dnos_in, locations = ~ coord_x + coord_y, 
  variogram.model = 'RMexp', 
  param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
            nugget = vario_fit$variogram.object[[1]]$param[['nugget']], 
            scale = vario_fit$variogram.object[[1]]$param[['scale']]),
  tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))
summary(reml_ku)
```

```{r}
plot(vario, type = "b", xlab = 'Distância de separação (m)', ylab = 'Semivariância')
lines(vario_fit, col = "blue", lty = 'dashed')
```

```{r}
grid <- sp::spsample(dnos_in, 10000, type = 'regular')
grid <- 
  sp::SpatialPointsDataFrame(
    coords = grid@coords, 
    data = data.frame(
      um = sp::over(grid, pedologia25) %>% unlist()),
    proj4string = grid@proj4string)
str(grid)
```


```{r}
colnames(grid@coords) <- colnames(dnos_in@coords)
pred_ku <- predict(
  reml_ku, newdata = grid, type = 'signal', signif = 0.95,
  control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_ku) <- TRUE
spplot(pred_ku)
str(pred_ku)
```


```{r}
krig_ku <- sp::spplot(pred_ku, zcol = 'se')
plot(krig_ku)
```

Validação cruzada do modelo utilizando apenas krigagem ordinária.

```{r}
validacao_ku <- georob::cv(reml_ku, nset = 375)
summary(validacao_ku)
```

```{r}
1 - sum((validacao_ku$pred$data - validacao_ku$pred$pred)^2) / 
  sum((validacao_ku$pred$data - mean(validacao_ku$pred$data))^2)

plot(validacao_ku)
```


```{r}
# Incerteza
cond_sim_ku <- gstat::krige(argila_ ~ um, dnos_in, grid, model = m_exp, nmax = 15, nsim = 8)
gridded(cond_sim_ku) <- TRUE
spplot(cond_sim_ku)
```

```{r}
beta_ku <- lm(argila_ ~ um, dnos_in@data) %>% coef()
g_ku <- gstat::gstat(formula = z ~ um, dummy = TRUE, model = m_exp, nmax = 15, beta = beta)
uncond_sim_ku <- predict(g_ku, grid, nsim = 8)
gridded(uncond_sim_ku) <- TRUE
spplot(uncond_sim_ku)
```

```{r}
uncond_sim_prop_ku <- 
  calc(stack(uncond_sim_ku), function (x) x > 50) %>% 
  calc(sum) %>% 
  calc(function (x) x / 8)
plot(uncond_sim_prop_ku, asp = 1)
```


#Parte iv
``` {r}
esta na tabela apresentada na aula 3 - 

(RE)ML Gaussiano
reml_fit <- georob::georob(
  areia_ ~ um + geo, pontos400in, locations = ~ coord_x + coord_y, variogram.model = 'RMexp', 
  param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
            nugget = vario_fit$variogram.object[[1]]$param[['nugget']], 
            scale = vario_fit$variogram.object[[1]]$param[['scale']]),
  tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))
summary(reml_fit)
plot(vario, type = "b", xlab = 'Distância de separação (m)', ylab = 'Semivariância')
lines(vario_fit, col = "red", lty = 'dashed')
lines(reml_fit, col = "blue", lty = 'dashed')
prof_reml_fit_scale <- 
  georob::profilelogLik(object = reml_fit, values = data.frame(scale = seq(50, 350, by = 10)))
```{r loglik-scale, error=TRUE, fig.asp=1, fig.cap='Perfil da função logarítmica da verossimilhança restrita para o parâmetro alcance (scale). A linhas verticais representam a estimativa e intervalo de confiança do parâmetro alcance. A interseção entre a linha horizontal e o perfil indica a região de 95% de confiança para o parâmetro alcance segundo o teste da razão de verossimilhança.'} plot(loglik ~ scale, prof_reml_fit_scale, type = "l") abline(v = summary(reml_fit)$param.aniso[[1]]['scale', ], lty = c("dashed", rep('dotted', 2)), col = 'red') abline(h = reml_fit$loglik - 0.5 * qchisq(0.95, 1), lty = "dotted")
```

```{r, fig.width=14, fig.height=7, fig.cap='Relação das estimativas da variância parcial (`variance`) e da variância residual (`nugget`) com as estimativas do alcance (`scale`).'}
op <- par(mfrow = c(1, 2))
plot(variance ~ scale, prof_reml_fit_scale, ylim = c(0, max(variance)), type = "l")
plot(nugget ~ scale, prof_reml_fit_scale, ylim = c(0, max(nugget)), type = "l")
par(op)
```

```{r, asp = 1}
par(mfrow=c(2,2))
plot(uncond_sim_prop_ko)
plot(uncond_sim_prop_ku)
plot(krig_ko)
plot(krig_ku)

```

